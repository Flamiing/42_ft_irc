/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   processCommand.cpp                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: guilmira <guilmira@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/08/22 20:10:01 by alaaouam          #+#    #+#             */
/*   Updated: 2023/08/29 11:05:02 by guilmira         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/Server.hpp"
#include "../../inc/Client.hpp"
#include "../../inc/commands.hpp"

static void commandProcessor(Server& server, Client& client, std::string& buffer, IRCMessage& messageIRC)
{
	if (messageIRC.cmd == JOIN)
		joinCommand(server, client, buffer, messageIRC.vector);
	else
		buffer = ERR_UNKNOWNCOMMAND(client.getNickname(), messageIRC.cmd);
//	else if (message[0] == PRIVMSG)
//		privmsgCommand(client, buffer, message);
//	else if (message[0] == NOTICE)
//		noticeCommand(client, buffer, message);
//	else if (message[0] == HELP)
//		helpCommand(client, buffer, message);
//	else if (message[0] == OPER)
//		operCommand(client, buffer, message);
//	else if (message[0] == KICK)
//		kickCommand(client, buffer, message);
//	else if (message[0] == TOPIC)
//		topicCommand(client, buffer, message);
//	else if (message[0] == QUIT)
//		quitCommand(client, buffer, message);
}


/* crearia una clase command para tener homogeneidad de metodos
y un atributo que fuese la propia linea */

/* Utilizo array directo para no tener que modificar la estructura del código 
Si options[] no parece váido, entonces yo crearía una clase command, con metodos para rellenar el array, utilizaría enums 
y modificaría bastante la estructura. También metería los typdef en en command.hpp

(*functionArray[i])(); // en una linea, se mantiene el codigo de abajo por legibilidad */;

/* #define COMMAND_NUMBER 6
typedef int myInt;
typedef void (*customFunctionType)(Server& server, Client& client, Command& command);
typedef void (Command::*type_function)();

static void fillFunctionArray(customFunctionType *functionArray)
{
	
}


static void commandProcessor(Server& server, Client& client, std::string& buffer, IRCMessage& messageIRC)
{

	std::string			options[COMMAND_NUMBER] = {PRIVMSG, HELP, OPER, KICK, TOPIC, QUIT};
	customFunctionType	functionArray[COMMAND_NUMBER];
	customFunctionType	function;

	functionArray[0] = &joinCommand(server, client, buffer, messageIRC);
	functionArray[1] = &privmsgCommand(client, buffer, message); //no pueden tener cada una diferente argumento
	for (int i = 0; i < COMMAND_NUMBER; i++)
	{
		if (!buffer.compare(options[i]))
		{
			function = functionArray[i];
			(*function)();
		}
	}
} */



	if (messageIRC.cmd == JOIN)
		joinCommand(server, client, buffer, messageIRC.vector);
	else
		buffer = ERR_UNKNOWNCOMMAND(client.getNickname(), messageIRC.cmd);
	else if (message[0] == PRIVMSG)
		privmsgCommand(client, buffer, message);
	else if (message[0] == NOTICE)
		noticeCommand(client, buffer, message);
	else if (message[0] == HELP)
		helpCommand(client, buffer, message);
	else if (message[0] == OPER)
		operCommand(client, buffer, message);
	else if (message[0] == KICK)
		kickCommand(client, buffer, message);
	else if (message[0] == TOPIC)
		topicCommand(client, buffer, message);
	else if (message[0] == QUIT)
		quitCommand(client, buffer, message);
}


void processCommand(Server& server, Client& client, std::string& buffer, IRCMessage& messageIRC)
{
	if (messageIRC.cmd == PASS)
		passCommand(server, client, buffer, messageIRC.vector);
	else if (client.getPassAuth() == true && messageIRC.cmd == USER)
		userCommand(client, buffer, messageIRC.vector);
	else if (client.getPassAuth() == true && messageIRC.cmd == NICK)
		nickCommand(server, client, buffer, messageIRC.vector);
	else if (messageIRC.cmd == PONG)
		return ;
	else if (client.getAuth() == true)
		commandProcessor(server, client, buffer, messageIRC);
	else
	{
		if (client.getAuth() == true)
			buffer = ERR_NOTREGISTERED(client.getNickname());
		else
			buffer = ERR_NOTREGISTERED(client.getWrongNickname());
	}
}